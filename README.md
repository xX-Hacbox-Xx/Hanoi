# Hanoi
# 本文在[玩具盒](https://www.hacbox.studio/index.php/%e7%8e%a9%e5%85%b7%e7%9b%92/)同步更新！图片无法阅读请移步至玩具盒！
------------
# C语言-汉诺塔问题

## 问题背景
> 法国数学家爱德华·卢卡斯曾编写过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。

## 算法分析
汉诺塔问题是递归算法的经典，可以说只要理解了递归核心算法，就理解了整个算法的结构。
###### 对于汉诺塔问题，可以分下面几种情况：
 1. 当只移动一个圆盘时，直接将圆盘从 A 针移动到 C 针。
 2. 若移动的圆盘为 n(n>1)，则分成几步走：
	1.  把 (n-1) 个圆盘从 A 针移动到 B 针（借助 C 针）；
	1.  A 针上的最后一个圆盘移动到 C 针；
	1.  B 针上的 (n-1) 个圆盘移动到 C 针（借助 A 针）；
###### 每做一遍，移动的圆盘少一个，逐次递减，最后当 n 为 1 时，完成整个移动过程。

## 源码展示
```c
#include <stdio.h>

void move(char getone, char putone)
{
    printf("%c-->%c\n", getone, putone);
}
void hanoi(int n, char one, char two, char three) /*将n个盘从one借助two,移到three*/
{
    if (n == 1)
        move(one, three);
    else
    {
        hanoi(n - 1, one, three, two);          //
        move(one, three);                       //核心代码
        hanoi(n - 1, two, one, three);          //
    }
}
int main()
{
    int m;
    printf("输入盘子数量:");
    scanf("%d", &m);
    printf("移动 %3d 个盘子的步骤为:\n", m);
    hanoi(m,'A','B','C');
    return 0;
}
```
